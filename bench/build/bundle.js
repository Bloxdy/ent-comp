/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./suite.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../../../usr/local/lib/node_modules/webpack/node_modules/process/browser.js":
/*!*************************************************!*\
  !*** (webpack)/node_modules/process/browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///(webpack)/node_modules/process/browser.js?");

/***/ }),

/***/ "../node_modules/fen-bench/index.js":
/*!******************************************!*\
  !*** ../node_modules/fen-bench/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nmodule.exports = Bench\n\n\n\nfunction Bench() {\n    var self = this\n\n\n    /*\n     * \n     *      API\n     * \n    */\n\n    this.testCases = []\n    this.testDuration = 150\n    this.pauseDuration = 10\n    this.maxMeasurements = 10\n\n    this.start = () => { if (self.running) return; self.running = true; runTests() }\n    this.stop = () => { self.running = false }\n    this.running = false\n\n    this.callback = () => { }\n\n    this.report = function () {\n        var clip = (str, len) => str.substr(0, len - 1).padEnd(len)\n        var fmt = (a, b, c) => clip(a, 25) + clip(b, 15) + c\n        var str = fmt('Name', 'Avg ops/sec', 'plus/minus')\n        self.testCases.forEach(item => {\n            if (!item._results) return\n            var speed = (parseFloat(item.ops.toPrecision(3)) + '').padStart(8)\n            var devpct = (Math.round(200 * item.dev / item.ops) + '%').padStart(5)\n            str += '\\n' + fmt(item.name, speed, devpct)\n        })\n        return str\n    }\n\n\n\n\n\n\n\n    /*\n     * \n     *      implementation \n     * \n    */\n\n\n    // helpers\n    var mean = arr => arr.reduce((prev, val) => prev + val, 0) / arr.length\n    var deviation = arr => {\n        var avg = mean(arr)\n        return Math.sqrt(mean(arr.map(num => (num - avg) ** 2)))\n    }\n    var now = (() => {\n        if (typeof performance === 'object') return () => performance.now()\n        if (typeof process === 'object') return () => {\n            var t = process.hrtime()\n            return t[0] * 1e3 + t[1] / 1e6\n        }\n        return () => Date.now()\n    })()\n\n\n\n    function conformTestCase(item) {\n        if (item._results) return\n        item.name = item.name || 'Unnamed'\n        item.fn = item.fn || (() => 0)\n        item.lastReturnValue = undefined\n        item._results = []\n        item.ops = 0\n        item.dev = 0\n    }\n\n\n\n    function runTests() {\n        var list = self.testCases\n        if (list.length === 0) throw 'Add some test cases!'\n\n        listCounter %= list.length\n        var item = list[listCounter]\n        conformTestCase(item)\n        listCounter++\n\n        // synchronously run one battery on one function\n        var res = battery(item.fn, self.testDuration)\n        item._results.unshift(res.duration)\n        item.lastReturnValue = res.lastReturnValue\n\n        // recalc mean/stdev\n        if (item._results.length > self.maxMeasurements) {\n            item._results.lenth = self.maxMeasurements\n        }\n        item.ops = mean(item._results)\n        item.dev = deviation(item._results)\n\n        // callback after full cycle\n        if (listCounter === list.length) self.callback()\n        if (self.running) setTimeout(runTests, self.pauseDuration)\n    }\n    var listCounter = 0\n\n\n\n\n    function battery(fn, dur) {\n        var start = now()\n        var ops = 0\n        var result = fn()\n        while (now() < start + dur) {\n            result = fn()\n            ops++\n        }\n        return {\n            duration: 1000 * ops / (now() - start),\n            lastReturnValue: result\n        }\n    }\n\n}\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../usr/local/lib/node_modules/webpack/node_modules/process/browser.js */ \"../../../../../../usr/local/lib/node_modules/webpack/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///../node_modules/fen-bench/index.js?");

/***/ }),

/***/ "../src/ECS.js":
/*!*********************!*\
  !*** ../src/ECS.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nmodule.exports = ECS\nvar DataStore = __webpack_require__(/*! ./dataStore */ \"../src/dataStore.js\")\n\n\n\n/*!\n * ent-comp: a light, *fast* Entity Component System in JS\n * @url      github.com/andyhall/ent-comp\n * @author   Andy Hall <andy@fenomas.com>\n * @license  MIT\n*/\n\n\n\n/**\n * Constructor for a new entity-component-system manager.\n * \n * ```js\n * var ECS = require('ent-comp')\n * var ecs = new ECS()\n * ```\n * @class\n * @constructor\n * @exports ECS\n * @typicalname ecs\n*/\n\nfunction ECS() {\n\tvar self = this\n\n\t/** \n\t * Hash of component definitions. Also aliased to `comps`.\n\t * \n\t * ```js\n\t * var comp = { name: 'foo' }\n\t * ecs.createComponent(comp)\n\t * ecs.components['foo'] === comp  // true\n\t * ecs.comps['foo']                // same\n\t * ```\n\t*/\n\tthis.components = {}\n\tthis.comps = this.components\n\n\n\n\t/*\n\t * \n\t * \t\tinternal properties:\n\t * \n\t*/\n\n\tvar components = this.components\n\n\t// counter for entity IDs\n\tvar UID = 1\n\n\t// Storage for all component state data:\n\t// storage['component-name'] = DataStore instance\n\tvar storage = {}\n\n\t// flat arrays of names of components with systems\n\tvar systems = []\n\tvar renderSystems = []\n\n\t// expose references to internals for debugging or hacking\n\tthis._storage = storage\n\tthis._systems = systems\n\tthis._renderSystems = renderSystems\n\n\n\n\n\n\t/*\n\t * \n\t * \n\t * \t\t\t\tPublic API\n\t * \n\t * \n\t*/\n\n\n\n\n\t/**\n\t * Creates a new entity id (currently just an incrementing integer).\n\t * \n\t * Optionally takes a list of component names to add to the entity (with default state data).\n\t * \n\t * ```js\n\t * var id1 = ecs.createEntity()\n\t * var id2 = ecs.createEntity([ 'some-component', 'other-component' ])\n\t * ```\n\t*/\n\tthis.createEntity = function (compList) {\n\t\tvar id = UID++\n\t\tif (Array.isArray(compList)) {\n\t\t\tcompList.forEach(compName => self.addComponent(id, compName))\n\t\t}\n\t\treturn id\n\t}\n\n\n\n\t/**\n\t * Deletes an entity, which in practice means removing all its components.\n\t * \n\t * ```js\n\t * ecs.deleteEntity(id)\n\t * ```\n\t*/\n\tthis.deleteEntity = function (entID) {\n\t\t// loop over all components and maybe remove them\n\t\t// this avoids needing to keep a list of components-per-entity\n\t\tObject.keys(storage).forEach(compName => {\n\t\t\tvar data = storage[compName]\n\t\t\tif (data.hash[entID]) {\n\t\t\t\tremoveComponentNow(entID, compName)\n\t\t\t}\n\t\t})\n\t\treturn self\n\t}\n\n\n\n\n\n\n\n\t/**\n\t * Creates a new component from a definition object. \n\t * The definition must have a `name`; all other properties are optional.\n\t * \n\t * Returns the component name, to make it easy to grab when the component\n\t * is being `require`d from a module.\n\t * \n\t * ```js\n\t * var comp = {\n\t * \t name: 'some-unique-string',\n\t * \t state: {},\n\t * \t order: 99,\n\t * \t multi: false,\n\t * \t onAdd:        (id, state) => { },\n\t * \t onRemove:     (id, state) => { },\n\t * \t system:       (dt, states) => { },\n\t * \t renderSystem: (dt, states) => { },\n\t * }\n\t * \n\t * var name = ecs.createComponent( comp )\n\t * // name == 'some-unique-string'\n\t * ```\n\t * \n\t * Note the `multi` flag - for components where this is true, a given \n\t * entity can have multiple state objects for that component.\n\t * For multi-components, APIs that would normally return a state object \n\t * (like `getState`) will instead return an array of them.\n\t*/\n\tthis.createComponent = function (compDefn) {\n\t\tif (!compDefn) throw 'Missing component definition'\n\t\tvar name = compDefn.name\n\t\tif (!name) throw 'Component definition must have a name property.'\n\t\tif (typeof name !== 'string') throw 'Component name must be a string.'\n\t\tif (name === '') throw 'Component name must be a non-empty string.'\n\t\tif (storage[name]) throw `Component ${name} already exists.`\n\n\t\t// rebuild definition object for monomorphism\n\t\tvar internalDef = {}\n\t\tinternalDef.name = name\n\t\tinternalDef.multi = !!compDefn.multi\n\t\tinternalDef.order = isNaN(compDefn.order) ? 99 : compDefn.order\n\t\tinternalDef.state = compDefn.state || {}\n\t\tinternalDef.onAdd = compDefn.onAdd || null\n\t\tinternalDef.onRemove = compDefn.onRemove || null\n\t\tinternalDef.system = compDefn.system || null\n\t\tinternalDef.renderSystem = compDefn.renderSystem || null\n\n\t\tcomponents[name] = internalDef\n\t\tstorage[name] = new DataStore()\n\n\t\tif (internalDef.system) {\n\t\t\tsystems.push(name)\n\t\t\tsystems.sort((a, b) => components[a].order - components[b].order)\n\t\t}\n\t\tif (internalDef.renderSystem) {\n\t\t\trenderSystems.push(name)\n\t\t\trenderSystems.sort((a, b) => components[a].order - components[b].order)\n\t\t}\n\n\t\treturn name\n\t}\n\n\n\n\n\n\t/**\n\t * Deletes the component definition with the given name. \n\t * First removes the component from all entities that have it.\n\t * \n\t * **Note:** This API shouldn't be necessary in most real-world usage - \n\t * you should set up all your components during init and then leave them be.\n\t * But it's useful if, say, you receive an ECS from another library and \n\t * you need to replace its components.\n\t * \n\t * ```js\n\t * ecs.deleteComponent( 'some-component' )\n\t * ```\n\t*/\n\tthis.deleteComponent = function (compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}`\n\n\t\tdata.flush()\n\t\tdata.list.forEach(obj => {\n\t\t\tvar id = obj.__id || obj[0].__id\n\t\t\tself.removeComponent(id, compName)\n\t\t})\n\n\t\tvar i = systems.indexOf(compName)\n\t\tvar j = renderSystems.indexOf(compName)\n\t\tif (i > -1) systems.splice(i, 1)\n\t\tif (j > -1) renderSystems.splice(j, 1)\n\n\t\tdelete components[compName]\n\t\tstorage[compName].dispose()\n\t\tdelete storage[compName]\n\n\t\treturn self\n\t}\n\n\n\n\n\t/**\n\t * Adds a component to an entity, optionally initializing the state object.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'foo',\n\t * \tstate: { val: 1 }\n\t * })\n\t * ecs.addComponent(id1, 'foo')             // use default state\n\t * ecs.addComponent(id2, 'foo', { val:2 })  // pass in state data\n\t * ```\n\t*/\n\tthis.addComponent = function (entID, compName, state) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\n\t\t// treat adding an existing (non-multi-) component as an error\n\t\tif (data.hash[entID] && !def.multi) {\n\t\t\tthrow `Entity ${entID} already has component: ${compName}.`\n\t\t}\n\n\t\t// create new component state object for this entity\n\t\tvar newState = Object.assign({}, { __id: entID }, def.state, state)\n\n\t\t// just in case passed-in state object had an __id property\n\t\tnewState.__id = entID\n\n\t\t// add to data store - for multi components, may already be present\n\t\tif (def.multi) {\n\t\t\tvar statesArr = data.hash[entID]\n\t\t\tif (!statesArr) {\n\t\t\t\tstatesArr = []\n\t\t\t\tdata.add(entID, statesArr)\n\t\t\t}\n\t\t\tstatesArr.push(newState)\n\t\t} else {\n\t\t\tdata.add(entID, newState)\n\t\t}\n\n\t\t// call handler and return\n\t\tif (def.onAdd) def.onAdd(entID, newState)\n\n\t\treturn this\n\t}\n\n\n\n\t/**\n\t * Checks if an entity has a component.\n\t * \n\t * ```js\n\t * ecs.addComponent(id, 'foo')\n\t * ecs.hasComponent(id, 'foo')       // true\n\t * ```\n\t*/\n\n\tthis.hasComponent = function (entID, compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\t\treturn !!data.hash[entID]\n\t}\n\n\n\n\n\n\t/**\n\t * Removes a component from an entity, triggering the component's \n\t * `onRemove` handler, and then deleting any state data.\n\t * \n\t * ```js\n\t * ecs.removeComponent(id, 'foo')\n\t * ecs.hasComponent(id, 'foo')     \t // false\n\t * ```\n\t*/\n\tthis.removeComponent = function (entID, compName) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\n\t\t// if comp isn't present, fail silently for multi or throw otherwise\n\t\tif (!data.hash[entID]) {\n\t\t\tif (def.multi) return self\n\t\t\telse throw `Entity ${entID} does not have component: ${compName} to remove.`\n\t\t}\n\n\t\t// removal implementations at end\n\t\tremoveComponentNow(entID, compName)\n\t\treturn self\n\t}\n\n\n\n\n\n\t/**\n\t * Get the component state for a given entity.\n\t * It will automatically have an `__id` property for the entity id.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'foo',\n\t * \tstate: { val: 0 }\n\t * })\n\t * ecs.addComponent(id, 'foo')\n\t * ecs.getState(id, 'foo').val       // 0\n\t * ecs.getState(id, 'foo').__id      // equals id\n\t * ```\n\t*/\n\n\tthis.getState = function (entID, compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\t\treturn data.hash[entID]\n\t}\n\n\n\n\n\t/**\n\t * Get an array of state objects for every entity with the given component. \n\t * Each one will have an `__id` property for the entity id it refers to.\n\t * Don't add or remove elements from the returned list!\n\t * \n\t * ```js\n\t * var arr = ecs.getStatesList('foo')\n\t * // returns something shaped like:\n\t * //   [\n\t * //     {__id:0, x:1},\n\t * //     {__id:7, x:2},\n\t * //   ]\n\t * ```  \n\t*/\n\n\tECS.prototype.getStatesList = function (compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\t\tdata.flush()\n\t\treturn data.list\n\t}\n\n\n\n\n\t/**\n\t * Makes a `getState`-like accessor bound to a given component. \n\t * The accessor is faster than `getState`, so you may want to create \n\t * an accessor for any component you'll be accessing a lot.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'size',\n\t * \tstate: { val: 0 }\n\t * })\n\t * var getEntitySize = ecs.getStateAccessor('size')\n\t * // ...\n\t * ecs.addComponent(id, 'size', { val:123 })\n\t * getEntitySize(id).val      // 123\n\t * ```  \n\t*/\n\n\tthis.getStateAccessor = function (compName) {\n\t\tif (!storage[compName]) throw `Unknown component: ${compName}.`\n\t\tvar hash = storage[compName].hash\n\t\treturn (id) => hash[id]\n\t}\n\n\n\n\n\t/**\n\t * Makes a `hasComponent`-like accessor function bound to a given component. \n\t * The accessor is much faster than `hasComponent`.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'foo',\n\t * })\n\t * var hasFoo = ecs.getComponentAccessor('foo')\n\t * // ...\n\t * ecs.addComponent(id, 'foo')\n\t * hasFoo(id) // true\n\t * ```  \n\t*/\n\n\tthis.getComponentAccessor = function (compName) {\n\t\tif (!storage[compName]) throw `Unknown component: ${compName}.`\n\t\tvar hash = storage[compName].hash\n\t\treturn (id) => !!hash[id]\n\t}\n\n\n\n\n\n\t/**\n\t * Tells the ECS that a game tick has occurred, causing component \n\t * `system` functions to get called.\n\t * \n\t * The optional parameter simply gets passed to the system functions. \n\t * It's meant to be a timestep, but can be used (or not used) as you like.    \n\t * \n\t * If components have an `order` property, they'll get called in that order\n\t * (lowest to highest). Component order defaults to `99`.\n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: foo,\n\t * \torder: 1,\n\t * \tsystem: function(dt, states) {\n\t * \t\t// states is the same array you'd get from #getStatesList()\n\t * \t\tstates.forEach(state => {\n\t * \t\t\tconsole.log('Entity ID: ', state.__id)\n\t * \t\t})\n\t * \t}\n\t * })\n\t * ecs.tick(30) // triggers log statements\n\t * ```\n\t*/\n\n\tthis.tick = function (dt) {\n\t\tdoDeferredMultiCleanup()\n\t\tfor (var i = 0; i < systems.length; i++) {\n\t\t\tvar compName = systems[i]\n\t\t\tvar data = storage[compName]\n\t\t\tdata.flush()\n\t\t\tvar comp = components[compName]\n\t\t\tcomp.system(dt, data.list)\n\t\t\tdata.flush()\n\t\t}\n\t\tdoDeferredMultiCleanup()\n\t\treturn self\n\t}\n\n\n\n\t/**\n\t * Functions exactly like `tick`, but calls `renderSystem` functions.\n\t * this effectively gives you a second set of systems that are \n\t * called with separate timing, in case you want to \n\t * [tick and render in separate loops](http://gafferongames.com/game-physics/fix-your-timestep/)\n\t * (which you should!).\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: foo,\n\t * \torder: 5,\n\t * \trenderSystem: function(dt, states) {\n\t * \t\t// states is the same array you'd get from #getStatesList()\n\t * \t}\n\t * })\n\t * ecs.render(1000/60)\n\t * ```\n\t*/\n\n\tthis.render = function (dt) {\n\t\tdoDeferredMultiCleanup()\n\t\tfor (var i = 0; i < renderSystems.length; i++) {\n\t\t\tvar compName = renderSystems[i]\n\t\t\tvar data = storage[compName]\n\t\t\tdata.flush()\n\t\t\tvar comp = components[compName]\n\t\t\tcomp.renderSystem(dt, data.list)\n\t\t\tdata.flush()\n\t\t}\n\t\tdoDeferredMultiCleanup()\n\t\treturn self\n\t}\n\n\n\n\n\t/**\n\t * Removes one particular instance of a multi-component.\n\t * To avoid breaking loops, the relevant state object will get nulled\n\t * immediately, and spliced from the states array later when safe \n\t * (after the current tick/render/animationFrame).\n\t * \n\t * ```js\n\t * // where component 'foo' is a multi-component\n\t * ecs.getState(id, 'foo')   // [ state1, state2, state3 ]\n\t * ecs.removeMultiComponent(id, 'foo', 1)\n\t * ecs.getState(id, 'foo')   // [ state1, null, state3 ]\n\t * // one JS event loop later...\n\t * ecs.getState(id, 'foo')   // [ state1, state3 ]\n\t * ```\n\t */\n\tthis.removeMultiComponent = function (entID, compName, index) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\t\tif (!def.multi) throw 'removeMultiComponent called on non-multi component'\n\n\t\t// throw if comp isn't present, or multicomp isn't present at index\n\t\tvar statesArr = data.hash[entID]\n\t\tif (!statesArr || !statesArr[index]) {\n\t\t\tthrow `Multicomponent ${compName} instance not found at index ${index}`\n\t\t}\n\n\t\t// removal implementations at end\n\t\tremoveMultiCompElement(entID, compName, index)\n\n\t\treturn self\n\t}\n\n\n\n\n\n\n\n\n\t/*\n\t * \n\t * \n\t *\t\tinternal implementation of various delete operations\n\t * \n\t * \n\t*/\n\n\n\n\n\t// remove given component from an entity\n\tfunction removeComponentNow(entID, compName) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) return\n\t\tvar state = data.hash[entID]\n\t\tif (!state) throw 'internal error, removing nulled component'\n\n\t\t// call onRemove handler - on each instance for multi components\n\t\tif (def.onRemove) {\n\t\t\tif (def.multi) {\n\t\t\t\tstate.forEach(state => {\n\t\t\t\t\tif (!state) return // todo ?\n\t\t\t\t\tdef.onRemove(entID, state)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tdef.onRemove(entID, state)\n\t\t\t}\n\t\t}\n\n\t\t// actual removal from data store\n\t\tif (def.multi) state.length = 0\n\t\tdata.remove(entID)\n\t}\n\n\n\n\t// remove one state from a multi component\n\tfunction removeMultiCompElement(entID, compName, index) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tvar statesArr = data.hash[entID]\n\t\tif (!statesArr) return\n\n\t\tvar state = statesArr[index]\n\t\tif (def.onRemove && state) {\n\t\t\tdef.onRemove(entID, state)\n\t\t}\n\n\t\t// null out and handle deferral\n\t\tstatesArr[index] = null\n\t\tmultiCompDeferrals.list.push({ entID, compName })\n\n\t\tif (!multiCompDeferrals.pendingTimeout) {\n\t\t\tmultiCompDeferrals.pendingTimeout = true\n\t\t\tsetTimeout(doDeferredMultiCleanup, 1)\n\t\t}\n\t}\n\n\n\tvar multiCompDeferrals = {\n\t\tpendingTimeout: false,\n\t\tlist: [],\n\t}\n\n\n\tfunction doDeferredMultiCleanup() {\n\t\tvar list = multiCompDeferrals.list\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tdoOneMultiCleanup(list[i])\n\t\t}\n\t\tmultiCompDeferrals.list.length = 0\n\t\tmultiCompDeferrals.pendingTimeout = false\n\t}\n\n\tfunction doOneMultiCleanup(obj) {\n\t\tvar { entID, compName } = obj\n\t\tvar statesArr = storage[compName].hash[entID]\n\t\tif (!statesArr) return\n\t\tfor (var i = 0; i < statesArr.length; i++) {\n\t\t\tif (statesArr[i]) continue\n\t\t\tstatesArr.splice(i, 1)\n\t\t\ti--\n\t\t}\n\t\t// if this leaves the states list empty, remove the whole component\n\t\tif (statesArr.length === 0) {\n\t\t\tremoveComponentNow(entID, compName)\n\t\t}\n\t}\n\n\n}\n\n\n\n//# sourceURL=webpack:///../src/ECS.js?");

/***/ }),

/***/ "../src/dataStore.js":
/*!***************************!*\
  !*** ../src/dataStore.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n/*\n * \n *      Encapsulates (mostly) a collection of objects, \n *      exposed both as a hash and as an array\n *      _map maps hash id to list index\n * \n *      Note this is a dumb store, it doesn't check any inputs at all.\n *      It also assumes every stored data object is stored like:\n *          dataStore.add(37, {__id:37} )\n * \n*/\n\n\nmodule.exports = class DataStore {\n\n    constructor() {\n        this.list = []\n        this.hash = {}\n        this._map = {}\n        this._pendingRemovals = []\n        this._pendingFlush = false\n    }\n\n\n    // add a new state object\n    add(id, stateObject) {\n        if (typeof this._map[id] === 'number') {\n            // this happens if id is removed/readded without flushing\n            var index = this._map[id]\n            this.hash[id] = stateObject\n            this.list[index] = stateObject\n        } else {\n            this._map[id] = this.list.length\n            this.hash[id] = stateObject\n            this.list.push(stateObject)\n        }\n    }\n\n\n    // remove - nulls the state object, to be removed later\n    remove(id) {\n        var index = this._map[id]\n        this.hash[id] = null\n        this.list[index] = null\n        this._pendingRemovals.push(id)\n        if (!this._pendingFlush) {\n            this._pendingFlush = true\n            setTimeout(() => this.flush(), 1)\n        }\n    }\n\n\n    // just sever references\n    dispose() {\n        this.list = null\n        this.hash = null\n        this._map = null\n        this._pendingRemovals = null\n    }\n\n\n    // deletes removed objects from data structures\n    flush() {\n        if (!this._pendingRemovals) return\n        while (this._pendingRemovals.length > 0) {\n            var id = this._pendingRemovals.pop()\n            // state obj could be non-null if component was removed/readded\n            if (this.hash[id] !== null) continue\n            removeElement(this, id)\n        }\n        this._pendingFlush = false\n    }\n\n}\n\n\n\n/*\n * \n *      actual remove logic, fixes up data structures after\n * \n * \n*/\n\nfunction removeElement(data, id) {\n    // current location of this element in the list\n    var index = data._map[id]\n    // for hash and map, just delete by id\n    delete data.hash[id]\n    delete data._map[id]\n    // now splice - either by popping or by swapping with final element\n    if (index === data.list.length - 1) {\n        data.list.pop()\n    } else {\n        // swap last item with the one we're removing\n        var swapped = data.list.pop()\n        data.list[index] = swapped\n        // need to fix _map for swapped item\n        if (swapped === null) {\n            // slowest but rarest case - swapped item is ALSO pending removal\n            var prevIndex = data.list.length\n            for (var swapID in data._map) {\n                if (data._map[swapID] === prevIndex) {\n                    data._map[swapID] = index\n                    return\n                }\n            }\n        } else {\n            var swappedID = swapped.__id || swapped[0].__id\n            data._map[swappedID] = index\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///../src/dataStore.js?");

/***/ }),

/***/ "./suite.js":
/*!******************!*\
  !*** ./suite.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ECS = __webpack_require__(/*! ../src/ECS */ \"../src/ECS.js\")\nvar Bench = __webpack_require__(/*! fen-bench */ \"../node_modules/fen-bench/index.js\")\nvar windowed = (typeof window !== 'undefined')\n\n\n\n\n/**********************  SETUP  ***********************/\n\nvar ecs = new ECS()\n\nvar NUM_ENTS = 10000\nvar NUM_COMPS = 1000\nvar NUM_COMPS_PER_ENT = 100\n\nvar correctCount = 0\nvar correctSum = 0\nvar ids = []\n\nconsole.log('Setting up tests...')\nsetUpECS(ecs)\n\n\nfunction setUpECS(ecs) {\n\n\t// real component\n\tecs.createComponent({\n\t\tname: 'real-comp',\n\t\tstate: { num: 1 }\n\t})\n\n\t// filler components\n\tfor (var i = 0; i < NUM_COMPS; i++) {\n\t\tecs.createComponent({\n\t\t\tname: 'filler' + i,\n\t\t\tstate: { a: 1, b: 2 }\n\t\t})\n\t}\n\n\t// entities\n\tids = []\n\tcorrectCount = 0\n\tcorrectSum = 0\n\tfor (var j = 0; j < NUM_ENTS; j++) {\n\t\tvar id = ecs.createEntity()\n\t\t// every entity gets filler comps\n\t\tvar cnum = (j * 13) % NUM_COMPS\n\t\tfor (var k = 0; k < NUM_COMPS_PER_ENT; k++) {\n\t\t\tvar fillerName = 'filler' + ((cnum + k) % NUM_COMPS)\n\t\t\tecs.addComponent(id, fillerName)\n\t\t}\n\t\t// add real component to most but not all entities\n\t\tif (j % 8 === 0) continue\n\t\tvar num = (j * 17) % 20\n\t\tecs.addComponent(id, 'real-comp', { num: num })\n\t\tcorrectSum += num\n\t\tcorrectCount++\n\t\tids.push(id)\n\t}\n\n\t// delete a few things in case that matters\n\tvar del = i => {\n\t\tvar id = ids[i]\n\t\tif (ecs.hasComponent(id, 'real-comp')) {\n\t\t\tcorrectCount--\n\t\t\tcorrectSum -= ecs.getState(id, 'real-comp').num\n\t\t}\n\t\tecs.deleteEntity(ids[i], true)\n\t\tids.splice(i, 1)\n\t}\n\tfor (var di = 44; di < 55; di++) del(di)\n}\n\n\n\n\n/**********************  TEST CASES  ***********************/\n\n\n\n\nvar bench = new Bench()\nbench.testDuration = 100\nbench.pauseDuration = 10\n\n\nbench.testCases.push({\n\tname: 'hasComponent',\n\tfn: function () {\n\t\tvar ct = 0\n\t\tfor (var i = 0; i < ids.length; i++) {\n\t\t\tif (ecs.hasComponent(ids[i], 'real-comp')) ct++\n\t\t}\n\t\treturn ct\n\t}\n})\n\n\n\nbench.testCases.push({\n\tname: 'getState',\n\tfn: function () {\n\t\tvar sum = 0\n\t\tfor (var i = 0; i < ids.length; i++) {\n\t\t\tsum += ecs.getState(ids[i], 'real-comp').num\n\t\t}\n\t\treturn sum\n\t}\n})\n\n\n\nbench.testCases.push({\n\tname: 'stateAccessor',\n\tfn: function () {\n\t\tvar acc = ecs.getStateAccessor('real-comp')\n\t\tvar sum = 0\n\t\tfor (var i = 0; i < ids.length; i++) {\n\t\t\tsum += acc(ids[i]).num\n\t\t}\n\t\treturn sum\n\t}\n})\n\n\nbench.testCases.push({\n\tname: 'componentAccessor',\n\tfn: function () {\n\t\tvar acc = ecs.getComponentAccessor('real-comp')\n\t\tvar ct = 0\n\t\tfor (var i = 0; i < ids.length; i++) {\n\t\t\tif (acc(ids[i])) ct++\n\t\t}\n\t\treturn ct\n\t}\n})\n\n\nbench.testCases.push({\n\tname: 'getStatesList',\n\tfn: function () {\n\t\tvar sum = 0\n\t\tvar list = ecs.getStatesList('real-comp')\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tsum += list[i].num\n\t\t}\n\t\treturn sum\n\t}\n})\n\n\n\n\n// sanity correctness check\nbench.testCases.forEach(item => {\n\tvar res = item.fn()\n\tif (res !== correctSum && res !== correctCount) throw 'Logic error!'\n})\n\n\n\n\n\n/**********************  EXECUTE  ***********************/\n\n\n\n\n\nif (windowed) {\n\n\t// browser\n\tvar but = document.querySelector('#run')\n\tbut.onclick = function () {\n\t\tif (!bench.running) bench.start()\n\t\telse bench.stop()\n\t\tbut.textContent = (bench.running) ? 'RUNNING' : 'RUN'\n\t}\n\n\tvar out = document.querySelector('#output')\n\tvar ct = 0\n\tbench.callback = function () {\n\t\tout.value = `\tRuns: ${++ct}\\n` + bench.report()\n\t}\n\n} else {\n\n\t// node\n\tconsole.log('Running tests...')\n\tbench.start()\n\tvar iter = 0\n\tbench.callback = function () {\n\t\tif (iter++ < 5) return\n\t\tconsole.log(bench.report() + '\\n')\n\t\titer = 0\n\t}\n\n}\n\n\n\n\n//# sourceURL=webpack:///./suite.js?");

/***/ })

/******/ });